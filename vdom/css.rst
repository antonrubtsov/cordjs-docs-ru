****************************************
Работа со стилями (CSS) в новых виджетах
****************************************

Общие принципы правильной работы со стилями
===========================================

В этом разделе собраны общие мысли о том, как нужно правильно работать со стилями, чтобы не было мучительно больно,
основанные на шишках, набитых за годы разработки веб-интерфейсов, с оглядкой на БЭМ и другие современные тенденции в
этой сфере. Они не претендуют на истину в последней инстанции и, надеюсь, будут развиваться и дополняться, однако
хочется верить, что эти знания окажутся полезны и помогут упорядочить CSS-хаос, который обычно процветает в
web-проектах.

Оптимизация стилей (упрощение "жизни" браузеру)
-----------------------------------------------

В MDN (Mozilla Developer Network) есть замечательная статья о том, как писать эффективный CSS --- `Writing efficient CSS
<https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Writing_efficient_CSS>`_ --- которая настоятельно рекомендуется
к прочтению. Если коротко, то можно выделять 2 главных правила:

* лучше использовать селекторы по названию классов и не использовать более "общие" селекторы (по названию тегов, по
  атрибутам и т.д.),
* следует максимально избегать селекторов с наследованием, особенно неограниченной глубины (без знака ``>``), вместо
  этого следуеть испольльзовать наследование свойств CSS от родительского элемента к дочерним.

Этими правилами мы будем руководствоваться для выработки принципов правильной организации CSS.

Изоляция названий CSS-классов виджетов
--------------------------------------

CSS --- проблемный язык. Две главные проблемы:

* глобальное пространство имён классов
* если свойства класса где-нибудь случайно переопределены, то это распространяется на всех и не контролируется

Решением проблемы пространства имён является (`заимствованное из БЭМ
<https://ru.bem.info/method/naming-convention/#%D0%98%D0%BC%D1%8F-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%B0>`_)
добавление уникального префикса, идентифицирующего класс виджета, абсолютно ко всем названиям CSS-классов, которые
объявлены внутри этого виджета. При этом можно легко избежать селекторов с наследованием и улучшить производительность:

.. code-block:: sass
  :linenos:
  :caption: someWidget.styl

  .someWidget
    .element
      background-color: gray
      &.highlighted
        background-color: green

VS

.. code-block:: sass
  :linenos:
  :emphasize-lines: 1, 3
  :caption: someWidget.styl

  .someWidget__element
    background-color: gray
    &.someWidget__highlighted
      background-color: green

При этом отпадает необходимость обязательного добавления класса к корневому элементу виджета, если для него не требуется
задать какие-нибудь специальные свойства.

Для удобства разработчиков добавление префиксов можно автоматизировать на этапе сборки и рендеринга шаблона виджета.
Если это сделать, разработчик физически не сможет пересечь названия CSS-классов разных виджетов даже специально. При
этом остаётся возможность внутри шаблона виджета использовать CSS-классы из общей CSS-библиотеки или фреймворка, если он
прописал соответствующую зависимость (:ref:`см ниже <explicit-dependencies>`). Однако, если он попробует использовать
такие классы в описании стилей виджета, то к ним автоматически добавится префикс и они перестанут быть связаны с
CSS-библиотекой.

Принцип разделения ответственности между родительским и дочерним виджетом
-------------------------------------------------------------------------

Во многих случаях, когда в шаблоне одного виджета используется другой (дочерний) виджет, родительскому виджету "нужно"
каким-либо образом отпозиционировать дочерний относительно других своих элементов. Для этого ему нужно задать стили для
корневого элемента дочернего виджета. Однако это является своего рода нарушением идеальной картины мира, когда каждый
виджет задаёт стили только для своих собственных элементов и не вмешивается в стили других виджетов.

Разрешить это противоречие поможет взгляд на корневой элемент дочернего виджета как на некий кастомный html-тег
в рамках родительского виджета. Ведь родительский виджет волен задавать стили для всех "не-виджетных" тегов в своём
шаблоне. А чтобы не родительский виджет не вмешивался в детали внутренней реализации дочернего, представим, что этот
кастомный html-тег поддерживает только ограниченный набор CSS-свойств, которые определяют позиционирование.

Отсюда следует набор правил, которые с высокой вероятностью помогут избежать противоречивых или неоднозначных стилей:

* Родительский виджет имеет право задавать стили **только** для корневого тега дочернего путём присвоения
  дополнительного CSS-класса дочернему виджету. Этот класс объявлен должен быть объявлен в пространстве имён (или
  зависимостях) родительского виджета, дочерний виджет о нём ничего не "знает".
* Родительский виджет имеет право задавать для корневого тега дочернего виджета только свойства, влияющие на
  позиционирование, такие как:

  * ``position``. Однако нельзя переопределять значение на ``position: static``, поскольку это может повлиять на
    отображение элементов внутри дочернего виджета, если в нём было задано значение ``absolute`` или ``relative``.
  * ``z-index``
  * ``margin``
  * ``top``, ``bottom``, ``left``, ``right``

* Свойства, заданные дополнительным классом в родительском виджете имеют больший приоритет (переопределяют) такие же
  свойства, описанные в стилях самого дочернего виджета (для корневого тега).
* Если дочерний виджет использует вышеуказанные свойства для своего корневого тега, то желательно описать эти
  особенности в документации и указать, какие возможности по позиционированию этого виджета предусмотрены.
* Все другие модификации внешнего вида дочернего виджета (`модификаторы
  <https://ru.bem.info/method/definitions/#%D0%9C%D0%BE%D0%B4%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80>`_
  в терминах БЭМ) должны поддерживаться внутри самого дочернего виджета и управляться снаружи с помощью обычных
  параметров/свойств/атрибутов (props) виджета, отличных от ``class``. Например:

  .. code-block:: html
    :linenos:
    :caption: parentWidget.vdom.html

    <div>
      <widget type="//SomeWidget" highlighted="true"/>
    </div>

  .. code-block:: smarty
    :linenos:
    :caption: someWidget.vdom.html

    <div class={{ element: true, highlighted: props.highlighted }}>
      some content
    </div>

.. _explicit-dependencies:

Принцип явных зависимостей
--------------------------

Из-за того, что CSS глобален по сути, очень часто можно увидеть в html-шаблонах использование классов, которые непонятно
где объявлены. Такой код, очевидно, трудно поддерживать, особенно если учитывать, что класс с одним и тем же названием
может быть объявлен в разных css/stylus файлах, или если селекторы вовсе заданы не через классы, а через названия тегов
с вложенностями.

Виджет --- относительно обособленная единица (кирпичик). Хочется минимизировать возможность воздействия на его поведение
факторами извне. Первое желание --- все стили виджета должны быть описаны внутри него самого (в его stylus-файле).
Однако в реальной жизни мы сталкиваемся со следующими ситуациями:

* мы можем захотеть использовать внешние библиотеки виджетов со своими стилями, например --- DatePicker из jQuery.UI,
* в проекте часто используется какой-либо внешний CSS-фреймворк, например --- Bootstrap или Framework7,
* наконец, у проекта может быть собственный внутренний мини-CSS-фреймворк, определяющий, например, как должны выглядеть
  кнопочки.

Поэтому, как минимум, у виджетов должен быть механизм явного определения внешних CSS-зависимостей. Таким образом,
посмотрев на список зависимостей у виджета, разработчик сможет легко локализовать причину того или иного отображения
элемента из ограниченного числа CSS-файлов.

Но если стили из таких библиотек/фреймворков используются в большинстве виджетов, то неудобно определять одни и те же
зависимости в каждом виджете. Поскольку виджет всегда существует в рамках какого-либо бандла, то в конфигурации бандла
можно определить список CSS-зависимостей, которые будут автоматически добавляться ко всем виджетам в этом бандле. Это
своего рода компромисс, т.к. список зависимостей виджета становится не настолько явным, но необходимость дополнительно
посмотреть список подключаемых файлов стилей в конфигурации бандла не должна вызывать больших проблем.

Отдельно можно выделить стили, которые делают так называемый css-reset. Можно договориться, что такие стили являются
патчем к браузерам, который позволяет получить консистентное отображение в разных браузерах, а не стилями в обычном
понимании. Т.е. reset просто обязан быть, виджеты не должны об этом заботиться и как-то прописывать это в своих
зависимостях. Это было бы довольно странно, поскольку такая зависимость, загруженная в один единственный виджет,
повлияла бы на все остальные, поскольку css-reset прописывает глобальные свойства отображения для названий тегов, а не
конкретных css-классов.

Про "скины"
-----------

Одна из популярных возможностей, которые даёт архитектура CSS --- лёгким движением руки изменять внешний вид (стилевое
оформление) приложения, изменив подключаемый CSS-файл со всякими цветами и иконками, иными словами --- система "шкурок"
или "скинов" (от слова skin).

Реализовать это можно разными способами:

1. **С помощью определения специального класса у тега body**. Виджеты определяют разные значения свойств в
   зависимости от контекстного класса скина, например, если у нас есть скины *dark* и *light*:

  .. code-block:: sass
    :linenos:
    :emphasize-lines: 1, 7
    :caption: someWidget.styl

    .dark
      .element
        background-color: gray
        &.highlighted
          background-color: green

    .light
      .element
        background-color: #fff
        &.highlighted
          background-color: lightgreen

  Этот способ имеет 2 недостатка:

  * активно используются селекторы с наследованием и ухудшается производительность браузера,
  * при добавлении нового скина или модификации существующего нужно пробежаться по всем виджетам --- это очень дорого.

  И единственное преимущество: шкурку можно переключать "на лету", не перезагружая страницу, просто загрузив
  соответствующий css-файл и переключив класс у ``body``.

2. **Используя возможности stylus**, определять для каждого *скина* файл с разными значениями переменных, определяющих
   цвета, иконки и бекграунды, и использовать эти переменные в конечных файлах стилей.

  .. code-block:: sass
    :linenos:
    :caption: dark-skin.styl

    $primaryBgColor = gray
    $highlightColor = green

  .. code-block:: sass
    :linenos:
    :caption: someWidget.styl

    @import '__skin__'

    .element
      background-color: $primaryBgColor
      &.highlighted
        background-color: $highlightColor

  Недостатки этого способа:

  * необходимость делать несколько сборок CSS --- по одной на каждый *скин*,
  * в случае переключения с одной шкурки на другую необходимо перезагрузить страницу,
  * каждый скин --- отдельный полноценный объём загружаемых из сети css-файлов, общего кода нет.

  Но с точки зрения структуры кода и гибкости --- это самый лучший вариант, поскольку позволяет использовать
  переменные из скинов как в файлах стилей вижетов, так и в общих библиотечных файлах стилей.

3. **Определить стили скина в виде общей библиотеки классов**, подключать эту библиотеку в качестве зависимости и
   использовать её классы в конечных шаблонах виджетов. Для разных *скинов* подключать разные библиотеки с одинаковым
   набором классов, но разными значениями свойств.

  .. code-block:: sass
    :linenos:
    :caption: dark-skin.styl

    .skin-primary-bg
      background-color: $primaryBackgroundColor

    .skin-highlighted-bg
      background-color: $highlightColor

  .. code-block:: smarty
    :linenos:
    :caption: someWidget.vdom.html

    <div class={{ element: true,
                  skinPrimaryBg: !props.highlighted
                  skinHighlightedBg: props.highlighted
               }}
    >
      some content
    </div>

  Недостатки:

  * шаблоны виджетов явно "знают" о скинах, код более громоздкий и неуклюжий,
  * в случае переключения с одной шкурки на другую необходимо перезагрузить страницу,
  * невозможно отделить скин от базовой CSS-библиотеки, поскольку мы можем использовать классы скина только в
    шаблонах виджетов, но не в других css/stylus файлах.

  Преимущество отностительно второго метода: не нужно делать отдельных сборок, и не нужно загружать и кешировать в
  браузер полностью новую версию всех css-файлов при изменении текущего скина пользователем.


Реализация работы с CSS для новых виджетов
==========================================

Как и для старых виджетов, для описание стилей используется один из улучшителей синтаксиса CSS --- Stylus. Однако, для
реализации вышеописанных принципов, файлы организованы более строго и сборщик cordjs производит с ними дополнительные
манипуляции.

Какие бывают файлы стилей и где они располагаются
-------------------------------------------------

* **Внешние CSS библиотеки/фреймворки.** Располагаются где-нибудь в папке ``public/vendor`` или ``public/assets`` и
  подлючаются с помощью директивы ``@require`` в основных stylus-файлах виджетов или настройки ``requireCss`` в
  конфигурационном файле бандла.
* **Внутренний CSS-фреймворк проекта** --- набор классов для общих базовых элементов и лейаута, форматирования контента
  и т.п., например как должны выглядеть кнопочки, параграфы текста, инпуты и т.д. Располагается в папке ``css`` в
  корне бандла (зачастую, "общего" бандла проекта, который называется ``common``). Подключается так же, как и внешние
  CSS-библиотеки, но для подключения должно быть использовано каконическое имя (с ``//``).
* **Общие stylus-библиотеки**, которые помогают убирать дублирование кода. Они не содержат конечных классов, но
  определяют переменные и базовые наборы свойств, используемые в нескольких других местах (общих библиотеках классов
  и виджетах). Располагается в папке ``css`` в корне бандла. Подключаются с помощью директивы ``@import`` в
  stylus-файлы внутренних библиотек или виджетов.
* **Основной stylus-файл виджета.** Объявляет набор классов, которые используются только в данном виджете и, возможно, в
  виджетах-наследниках. Располагается в папке виджета, называется так же, как и класс виджета, но со строчной буквы и
  с расширением ``.styl``. При наличии автоматически добавляется в css-зависимости виджета при сборке.
* **Дополнительные stylus-файлы виджета.** Могут понадобится, если в основном файле разросся и удобно выделить какие-то
  куски в отдельные файлы. Располагаются в папке виджета. Подключаются с помощью директивы ``@import`` с
  использованием относительного (локального) пути в основной файл виджета.

Как включать общие stylus файлы с переменными и библиотеками
------------------------------------------------------------

Для вынесения общих кусков stylus-кода (обычно это какие-либо переменные или базовые заготовки для классов), которые
используются в нескольких конечных файлах стилей, следует использовать обычную директиву ``@import``. Путь к требуемому
stylus-файлу можно задать несколькими способами:

* Каноническое имя в формате cordjs (с двойным слешом), например: ``common//baseColors``. Можно указывать как
  абсолютный (начинающийся со слеша), так и относительный путь (будет браться в расчёт бандл виджета). Двойной слеш
  в таком пути будет заменяться на ``/css/`` --- специальную папку для размещения общих стилей бандла.
* Путь относительно папки текущего stylus-файла (это либо папка виджета, либо папка ``css`` в корне бандла). Он может
  начинаться либо с ``./`` либо просто названием stylus-файла или подпапки.
* *(пока не реализовано)* Специальное название ``__super__`` может использоваться в основном stylus-файле виджета,
  который наследуется от другого виджета, и интерпретируется как импорт основного файла стилей родительского виджета.

Использование расширение ``.styl`` в путях не обязательно (и даже не желательно).

Пример объявления зависимостей:

.. code-block:: sass
  :linenos:
  :emphasize-lines: 1,2
  :name: import-example
  :caption: someWidget.styl

  @import 'common//baseColors'
  @import 'subStyle'

  .someClass
    background-color: $mainBackground

Таким образом, можно испортировать stylus-файлы только из текущей папки или из специальных папок ``css`` в корне бандла.
Использовать стили из других виджетов (за исключением случая наследования) нельзя.

.. note::

  Директивой ``@import`` можно включать только stylus-файлы, добавление `буквалных ссылок на css-файлы
  <https://learnboost.github.io/stylus/docs/import.html#literal-css>`_, поддерживаемых в css, запрещено. Для добавления
  зависимостей от других файлов стилей используйте директиву ``@require`` (см. следующий подраздел).

Как добавлять зависимости от общей библиотеки стилей, внешних CSS-библиотек и фреймворков
-----------------------------------------------------------------------------------------

В отличие от *старых* виджетов (виджетов 1.0), в которых css-зависимости определялись в самом классе виджета через
свойство ``@css``, в новых виджетах они объявляются в основном stylus-файле виджета (который называется так же, как и
класс виджета, только со строчной буквы) посредством директивы ``@require``. Путь к требуемому файлу можно задать двумя
способами:

* Каноническое имя в формате cordjs (с двойным слешом), например: ``common//baseStyles``. Можно указывать как
  абсолютный (начинающийся со слеша), так и относительный путь (будет браться в расчёт бандл виджета). Двойной слеш
  в таком пути будет заменяться на ``/css/`` --- специальную папку для размещения общих стилей бандла.
* Абсолютный URL, начинающийся с ``/assets/`` или ``/vendor/`` --- для добавление зависимостей от внешних
  css-фреймворков. Расширение ``.css`` можно не указывать.

Пример объявления зависимостей:

.. code-block:: sass
  :linenos:
  :emphasize-lines: 1,2
  :name: require-example
  :caption: someWidget.styl

  @require '/vendor/bootstrap/bootstrap.css'
  @require 'common//baseStyles'

  @import '//bundleColors'

  .someClass
    color: $primary

Сборщик вырезает директивы ``@require``, прежде чем компилировать stylus-файл в css. Таким образом, воспользоваться
``@require``, `как обычно в stylus <https://learnboost.github.io/stylus/docs/import.html#require>`_, не получится,
следует использовать ``@import``.

.. warning::

  ``@require`` можно использовать только в основном stylus-файле виджета. Т.е. нельзя определить зависимость
  зависимости, сборщик выдаст ошибку. Это объясняется следующим: объявляя зависимость в основном файле виджета, мы
  хотим подключить стили для использования в самом виджете (его шаблоне), а объявляя зависимость в любом другом файле,
  мы, очевидно, хотим *переопределить какие-либо селекторы*, что само по себе является анти-паттерном (см. выше).


Особый случай --- наследование стилей при неследовании виджетов
---------------------------------------------------------------

TODO

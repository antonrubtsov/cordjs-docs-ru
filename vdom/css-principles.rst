*******************************************
Общие принципы правильной работы со стилями
*******************************************

В этом разделе собраны общие мысли о том, как нужно правильно работать со стилями, чтобы не было мучительно больно,
основанные на шишках, набитых за годы разработки веб-интерфейсов, с оглядкой на БЭМ и другие современные тенденции в
этой сфере. Они не претендуют на истину в последней инстанции и, надеюсь, будут развиваться и дополняться, однако
хочется верить, что эти знания окажутся полезны и помогут упорядочить CSS-хаос, который обычно процветает в
web-проектах.


Оптимизация стилей (упрощение "жизни" браузеру)
===============================================

В MDN (Mozilla Developer Network) есть замечательная статья о том, как писать эффективный CSS --- `Writing efficient CSS
<https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Writing_efficient_CSS>`_ --- которая настоятельно рекомендуется
к прочтению. Если коротко, то можно выделять 2 главных правила:

* лучше использовать селекторы по названию классов и не использовать более "общие" селекторы (по названию тегов, по
  атрибутам и т.д.),
* следует максимально избегать селекторов с наследованием, особенно неограниченной глубины (без знака ``>``), вместо
  этого следуеть испольльзовать наследование свойств CSS от родительского элемента к дочерним.

Этими правилами мы будем руководствоваться для выработки принципов правильной организации CSS.


Изоляция названий CSS-классов виджетов
======================================

CSS --- проблемный язык. Две главные проблемы:

* глобальное пространство имён классов
* если свойства класса где-нибудь случайно переопределены, то это распространяется на всех и не контролируется

Решением проблемы пространства имён является (`заимствованное из БЭМ
<https://ru.bem.info/method/naming-convention/#%D0%98%D0%BC%D1%8F-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%B0>`_)
добавление уникального префикса, идентифицирующего класс виджета, абсолютно ко всем названиям CSS-классов, которые
объявлены внутри этого виджета. При этом можно легко избежать селекторов с наследованием и улучшить производительность:

.. code-block:: sass
  :linenos:
  :caption: widgets/someWidget/someWidget.styl

  .someWidget
    .element
      background-color: gray
      &.highlighted
        background-color: green

VS

.. code-block:: sass
  :linenos:
  :emphasize-lines: 1, 3
  :caption: widgets/someWidget/someWidget.styl

  .someWidget__element
    background-color: gray
    &.someWidget__highlighted
      background-color: green

При этом отпадает необходимость обязательного добавления класса к корневому элементу виджета, если для него не требуется
задать какие-нибудь специальные свойства.

Для удобства разработчиков добавление префиксов можно автоматизировать на этапе сборки и рендеринга шаблона виджета.
Если это сделать, разработчик физически не сможет пересечь названия CSS-классов разных виджетов даже специально. При
этом остаётся возможность внутри шаблона виджета использовать CSS-классы из общей CSS-библиотеки или фреймворка, если он
прописал соответствующую зависимость (:ref:`см ниже <explicit-dependencies>`). Однако, если он попробует использовать
такие классы в описании стилей виджета, то к ним автоматически добавится префикс и они перестанут быть связаны с
CSS-библиотекой.


Принцип разделения ответственности между родительским и дочерним виджетом
=========================================================================

Во многих случаях, когда в шаблоне одного виджета используется другой (дочерний) виджет, родительскому виджету "нужно"
каким-либо образом отпозиционировать дочерний относительно других своих элементов. Для этого ему нужно задать стили для
корневого элемента дочернего виджета. Однако это является своего рода нарушением идеальной картины мира, когда каждый
виджет задаёт стили только для своих собственных элементов и не вмешивается в стили других виджетов.

Разрешить это противоречие поможет взгляд на корневой элемент дочернего виджета как на некий кастомный html-тег
в рамках родительского виджета. Ведь родительский виджет волен задавать стили для всех "не-виджетных" тегов в своём
шаблоне. А чтобы не родительский виджет не вмешивался в детали внутренней реализации дочернего, представим, что этот
кастомный html-тег поддерживает только ограниченный набор CSS-свойств, которые определяют позиционирование.

Отсюда следует набор правил, которые с высокой вероятностью помогут избежать противоречивых или неоднозначных стилей:

* Родительский виджет имеет право задавать стили **только** для корневого тега дочернего путём присвоения
  дополнительного CSS-класса дочернему виджету. Этот класс объявлен должен быть объявлен в пространстве имён (или
  зависимостях) родительского виджета, дочерний виджет о нём ничего не "знает".
* Родительский виджет имеет право задавать для корневого тега дочернего виджета только свойства, влияющие на
  позиционирование, такие как:

  * ``position``. Однако нельзя переопределять значение на ``position: static``, поскольку это может повлиять на
    отображение элементов внутри дочернего виджета, если в нём было задано значение ``absolute`` или ``relative``.
  * ``z-index``
  * ``margin``
  * ``top``, ``bottom``, ``left``, ``right``

* Свойства, заданные дополнительным классом в родительском виджете имеют больший приоритет (переопределяют) такие же
  свойства, описанные в стилях самого дочернего виджета (для корневого тега).
* Если дочерний виджет использует вышеуказанные свойства для своего корневого тега, то желательно описать эти
  особенности в документации и указать, какие возможности по позиционированию этого виджета предусмотрены.
* Все другие модификации внешнего вида дочернего виджета (`модификаторы
  <https://ru.bem.info/method/definitions/#%D0%9C%D0%BE%D0%B4%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80>`_
  в терминах БЭМ) должны поддерживаться внутри самого дочернего виджета и управляться снаружи с помощью обычных
  параметров/свойств/атрибутов (props) виджета, отличных от ``class``. Например:

  .. code-block:: html
    :linenos:
    :caption: widgets/parentWidget/parentWidget.vdom.html

    <div>
      <widget type="//SomeWidget" highlighted="true"/>
    </div>

  .. code-block:: smarty
    :linenos:
    :caption: widgets/someWidget/someWidget.vdom.html

    <div class={{ element: true, highlighted: props.highlighted }}>
      some content
    </div>

.. _explicit-dependencies:


Принцип явных зависимостей
==========================

Из-за того, что CSS глобален по сути, очень часто можно увидеть в html-шаблонах использование классов, которые непонятно
где объявлены. Такой код, очевидно, трудно поддерживать, особенно если учитывать, что класс с одним и тем же названием
может быть объявлен в разных css/stylus файлах, или если селекторы вовсе заданы не через классы, а через названия тегов
с вложенностями.

Виджет --- относительно обособленная единица (кирпичик). Хочется минимизировать возможность воздействия на его поведение
факторами извне. Первое желание --- все стили виджета должны быть описаны внутри него самого (в его stylus-файле).
Однако в реальной жизни мы сталкиваемся со следующими ситуациями:

* мы можем захотеть использовать внешние библиотеки виджетов со своими стилями, например --- DatePicker из jQuery.UI,
* в проекте часто используется какой-либо внешний CSS-фреймворк, например --- Bootstrap или Framework7,
* наконец, у проекта может быть собственный внутренний мини-CSS-фреймворк, определяющий, например, как должны выглядеть
  кнопочки.

Поэтому, как минимум, у виджетов должен быть механизм явного определения внешних CSS-зависимостей. Таким образом,
посмотрев на список зависимостей у виджета, разработчик сможет легко локализовать причину того или иного отображения
элемента из ограниченного числа CSS-файлов.

Но если стили из таких библиотек/фреймворков используются в большинстве виджетов, то неудобно определять одни и те же
зависимости в каждом виджете. Поскольку виджет всегда существует в рамках какого-либо бандла, то в конфигурации бандла
можно определить список CSS-зависимостей, которые будут автоматически добавляться ко всем виджетам в этом бандле. Это
своего рода компромисс, т.к. список зависимостей виджета становится не настолько явным, но необходимость дополнительно
посмотреть список подключаемых файлов стилей в конфигурации бандла не должна вызывать больших проблем.

Отдельно можно выделить стили, которые делают так называемый css-reset. Можно договориться, что такие стили являются
патчем к браузерам, который позволяет получить консистентное отображение в разных браузерах, а не стилями в обычном
понимании. Т.е. reset просто обязан быть, виджеты не должны об этом заботиться и как-то прописывать это в своих
зависимостях. Это было бы довольно странно, поскольку такая зависимость, загруженная в один единственный виджет,
повлияла бы на все остальные, поскольку css-reset прописывает глобальные свойства отображения для названий тегов, а не
конкретных css-классов.


Про "скины"
===========

Одна из популярных возможностей, которые даёт архитектура CSS --- лёгким движением руки изменять внешний вид (стилевое
оформление) приложения, изменив подключаемый CSS-файл со всякими цветами и иконками, иными словами --- система "шкурок"
или "скинов" (от слова skin).

Реализовать это можно разными способами:

1. **С помощью определения специального класса у тега body**. Виджеты определяют разные значения свойств в
   зависимости от контекстного класса скина, например, если у нас есть скины *dark* и *light*:

  .. code-block:: sass
    :linenos:
    :emphasize-lines: 1, 7
    :caption: widgets/someWidget/someWidget.styl

    .dark
      .element
        background-color: gray
        &.highlighted
          background-color: green

    .light
      .element
        background-color: #fff
        &.highlighted
          background-color: lightgreen

  Этот способ имеет 2 недостатка:

  * активно используются селекторы с наследованием и ухудшается производительность браузера,
  * при добавлении нового скина или модификации существующего нужно пробежаться по всем виджетам --- это очень дорого.

  И единственное преимущество: шкурку можно переключать "на лету", не перезагружая страницу, просто загрузив
  соответствующий css-файл и переключив класс у ``body``.

2. **Используя возможности stylus**, определять для каждого *скина* файл с разными значениями переменных, определяющих
   цвета, иконки и бекграунды, и использовать эти переменные в конечных файлах стилей.

  .. code-block:: sass
    :linenos:
    :caption: bundles/common/css/dark-skin.styl

    $primaryBgColor = gray
    $highlightColor = green

  .. code-block:: sass
    :linenos:
    :caption: widgets/someWidget/someWidget.styl

    @import '__skin__'

    .element
      background-color: $primaryBgColor
      &.highlighted
        background-color: $highlightColor

  Недостатки этого способа:

  * необходимость делать несколько сборок CSS --- по одной на каждый *скин*,
  * в случае переключения с одной шкурки на другую необходимо перезагрузить страницу,
  * каждый скин --- отдельный полноценный объём загружаемых из сети css-файлов, общего кода нет.

  Но с точки зрения структуры кода и гибкости --- это самый лучший вариант, поскольку позволяет использовать
  переменные из скинов как в файлах стилей вижетов, так и в общих библиотечных файлах стилей.

3. **Определить стили скина в виде общей библиотеки классов**, подключать эту библиотеку в качестве зависимости и
   использовать её классы в конечных шаблонах виджетов. Для разных *скинов* подключать разные библиотеки с одинаковым
   набором классов, но разными значениями свойств.

  .. code-block:: sass
    :linenos:
    :caption: bundles/common/css/dark-skin.styl

    .skin-primary-bg
      background-color: $primaryBackgroundColor

    .skin-highlighted-bg
      background-color: $highlightColor

  .. code-block:: smarty
    :linenos:
    :caption: widgets/someWidget/someWidget.vdom.html

    <div class={{ element: true,
                  skinPrimaryBg: !props.highlighted
                  skinHighlightedBg: props.highlighted
               }}
    >
      some content
    </div>

  Недостатки:

  * шаблоны виджетов явно "знают" о скинах, код более громоздкий и неуклюжий,
  * в случае переключения с одной шкурки на другую необходимо перезагрузить страницу,
  * невозможно отделить скин от базовой CSS-библиотеки, поскольку мы можем использовать классы скина только в
    шаблонах виджетов, но не в других css/stylus файлах.

  Преимущество отностительно второго метода: не нужно делать отдельных сборок, и не нужно загружать и кешировать в
  браузер полностью новую версию всех css-файлов при изменении текущего скина пользователем.

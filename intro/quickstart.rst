*********************************
Начало работы (Quick Start Guide)
*********************************

Это руководство поможет быстро развернуть ваш первый проект на CordJS и начать разрабатывать приложение.

.. _quickstart-install:

Установка CordJS
================

Фреймворк активно использует инфраструктуру Node.js, поэтому в первую очередь необходимо установить его. Проще всего
установить его используя систему пакетов в вашем Linux-дистрибутиве или OS X --- так будет проще обновлять. Но на
всякий случай для OS X можно скачать инсталлятор: https://nodejs.org/download/. На момент написания документации
поддерживается работа в версиях Node.js 0.12.x. Полноценная работа в Windows не поддерживается.

Установить CordJS очень просто из командной строки:

.. code-block:: bash

  sudo npm install -g cordjs
  cordjs --help

После этого в консоли будет доступна команда ``cordjs``, которая выполняет сборку (компиляцию) проекта и удобную
работу в "режиме разработчика".

.. _quickstart-create-project:

Создание нового проекта
=======================

К сожалению, команда ``cordjs`` пока не умеет создавать каркас пустого проекта автоматически. Но чтобы не создавать
всю структуру директорий вручную, можно воспользоваться специально подготовленным репозиторием на Github с пустым
проектом: https://github.com/cordjs/example-project:

.. code-block:: bash

  wget https://github.com/cordjs/example-project/archive/master.zip
  unzip master.zip
  cd example-project-master/
  ls -la

Большинство зависимостей, необходимых для базовой работы фреймворка, прописаны в файле ``package.json``. Чтобы их
установить (в папку ``node_modules``) необходимо, находясь в корне проекта, выполнить команду:

.. code-block:: bash

  npm install

Теперь, когда у нас есть конрневая директория проекта с базовой структурой, необходимо добавить в него пару *бандлов*
--- крупных блоков кода (модулей) из которых собирается приложение на CordJS:

* ``cord/core`` --- ядро фреймворка, бандл, в котором собраны базовые классы и сервисы, необходимые для разработки.
* ``hello/example`` --- бандл, в котором будут располагаться исходники данного приложения-примера (hello world!)

Все бандлы в проекте располагаются в директории ``public/bundles``. В рамках этой (корневой) директории бандлы могут
иметь "неплоскую" структуру, т.е. иметь произвольную структуру поддиректорий и, таким образом, разделять пространства
имён. Так, для собственных бандлов фреймворка зарезервировано пространство ``cord``, а для целей данного руководства
мы будем использовать пространство имён ``hello``.

Ядро фреймворка можно склонировать из репозитория на гитхабе. Его не следует комитить в собственный репозиторий,
чтобы легко получать обновления.

.. code-block:: bash

  cd public/bundles/cord
  git clone https://github.com/cordjs/core.git

Собственный бандл проекта можно создать вручную, а все исходники, в общем случае, следует содержать в репозитории
проекта. Создадим бандл ``example`` в пространстве имён ``hello``:

.. code-block:: bash

  # go to public/bundles
  cd ..
  mkdir -p hello/example
  cd hello/example
  touch config.coffee

Минимальное требование к структуре бандла --- наличие файла ``config.coffee`` в корне. Файл должен быть AMD-модулем и
возвращать JSON-структуру с конфигурацией бандла (роутами, сервисами и пр.):

.. code-block:: coffee
  :linenos:
  :caption: public/bundles/hello/example/config.coffee

  define ->
    {}

Для того, чтобы "включить" вновь созданный бандл в проекте, необходимо добавить его в конфигурационный файл проекта:

.. code-block:: coffee
  :linenos:
  :caption: public/app/application.coffee

  define -> [
    'hello/example'
  ]

Включать ``cord/core`` не нужно, он всегда добавляется автоматически.

Таким образом, мы получили базовый пустой проект и, наконец, можем начать писать код!

.. _quickstart-hello-world:

Hello World!
============

Для начала, мы хотим получить простую html-страничку с фразой "Hello world!". В CordJS всё, что видит пользователь
--- это виджеты, поэтому в первую очередь нам нужно создать виджет такой странички. С точки зрения исходников, виджет
представляет собой подпапку в папке ``widgets`` какого-либо бандла, в которой располагаются несколько исходных файлов
виджета. Находясь в корне проекта, выполните команды:

.. code-block:: bash

  cd public/bundles/hello/example
  mkdir -p widgets/helloWorldPage
  cd widgets/helloWorldPage
  touch HelloWorldPage.coffee
  touch helloWorldPage.html

Создадим минимальный пустой класс виджета. Можете пока не обращать внимания на свойство ``behaviourClass``. Файл
класса виджета должен называться так же, как и папка, но с заглавной буквы.

.. code-block:: coffee
  :linenos:
  :caption: public/bundles/hello/example/widgets/helloWorldPage/HelloWorldPage.coffee

  define [
    'cord!Widget'
  ], (Widget) ->

    class HelloWorldPage extends Widget

      behaviourClass: false

Файл шаблона виджета называется так же, как и папка, с расширением ``.html``. В качестве шаблонизатора используется
dustjs.

.. code-block:: html
  :linenos:
  :caption: public/bundles/hello/example/widgets/helloWorldPage/helloWorldPage.html

  <!doctype html>
    <head>
      {#css/}
    </head>

    <body>
      <h1>Hello World!</h1>
      {#widgetInitializer/}
    </body>
  </html>

Обратите внимание на использование двух плагинов ``{#css/}`` и ``{#widgetInitializer/}``. Для корректной работы
фреймвовка они должны быть вставлены в шаблон базового виджета (который владеет тегом ``<html>``) именно таким образом.

.. note::

  Позже станет понятно, что такой **базовый** виджет, который содержит теги ``html/head/body``, в одном
  пользовательском приложении только один.

Роуты
-----

Теперь, когда у нас есть готовый виджет страницы, осталось только сообщить фреймворку, по какому URL его показывать.
Для этого необходимо дописать пару строк в файле конфигурации бандла:

.. code-block:: coffee
  :linenos:
  :caption: public/bundles/hello/example/config.coffee

  define ->
    routes:
      '/':  # корневая страница
        widget: '//HelloWorldPage'

Двойной слеш в начале пути к виджету означает "корень текущего бандла".


Запуск
------

Теперь всё готово для запуска приложения. Находясь в корне проекта, выполните команду:

.. code-block:: bash

  cordjs run -w -c developer

Команда произведёт сборку проекта и запустит его в виде веб-сервера на Node.js, который "слушает" адрес по умолчанию
http://127.0.0.1:18180.

Во время сборки происходит компиляция ``.coffee`` в ``.js``, ``.styl`` в ``.css`` и т.д., дополнительные манипуляции
с исходниками. Сборка производится в отдельную подпапку ``target`` в корне проекта.

  Опция ``-w`` заставляет утилиту "слушать" изменения во всех исходниках и автоматически пересобирать/перезапускать
  приложение при любых изменениях.

  Опция ``-c developer`` задаёт название конфигурационного файла в из папки ``conf/``. В файле ``developer.js``
  установленны параметры, облегчающие разработку и отладку, такие как livereload --- автоматическая перезагрузка
  страницы (не нужно нажимать ``F5``) после каждой пересборки проекта.

Теперь можно открыть адрес http://127.0.0.1:18180/ в любом браузере и увидеть результат. Мы получили минимальное
рабочее приложение, разработанное с использованием CordJS. Но по функциональности оно ничем не отличается от
статической html-страницы. Далее мы усложним пример, чтобы показать основную суть и возможности, которые
предоставляет CordJS.

.. _quickstart-layout:

Добавим структуру
=================

CordJS создан с учётом потребности создавать относительно "большие" приложения, у которых имеется далеко не один
пользовательский экран. В таких приложениях обычно есть общие элементы, которые повторяются во всех или почти всех
экранах, например, навигация и подвал (footer). Для того чтобы не повторять базовую разметку и элементы навигации
каждый раз, в CordJS существует механизм так называемых "лейаутов" (layout), т.е. возможность "расширения" шаблона
одного виджета шаблоном другого.

Самый очевидный лейаут, который присутствует в каждом веб-приложении --- виджет, который владеет базовой разметкой
html-страницы (тегами ``html``, ``head`` и ``body``. Обычно такой виджет называется ``BaseLayout`` и является
единственным на всё приложение. Давайте его создадим:

.. code-block:: coffee
  :linenos:
  :caption: public/bundles/hello/example/widgets/baseLayout/BaseLayout.coffee

  define [
    'cord!Widget'
  ], (Widget) ->

    class BaseLayout extends Widget

      behaviourClass: false

.. code-block:: html
  :linenos:
  :caption: public/bundles/hello/example/widgets/baseLayout/baseLayout.html
  :emphasize-lines: 7

  <!doctype html>
    <head>
      {#css/}
    </head>

    <body>
      {#placeholder/}
      {#widgetInitializer/}
    </body>
  </html>

Обратите внимание, что вместо надписи "Hello World!" тут находится плагин ``{#placeholder/}``. Это специальная
конструкция, которая обозначает место, в которое будет вставляться контент других виджетов, которые используют этот
виджет в качестве лейаута. Проще один раз увидеть... Перепишем шаблон виджета ``HelloWorldPage`` таким образом,
чтобы он использовал вновь созданный ``BaseLayout``:

.. code-block:: html
  :linenos:
  :caption: public/bundles/hello/example/widgets/helloWorldPage/helloWorldPage.html
  :emphasize-lines: 3

  {#extend type="//BaseLayout"}
    {#inline}
      <h1>Hello World!</h1>
    {/inline}
  {/extend}

..

  ``{#extend}`` --- специальный плагин, который обозначает, что у текущего виджета нет собственного "корневого"
  DOM-элемента, а он только добавит контент в указанный layout-виджет. Всё, что заключено между открывающим и
  закрывающим "тегом" ``extend``, будет вставлено в плейсхолдер (placeholder) виджета ``BaseLayout``.

  ``{#inline}`` --- специальный плагин, который предназначен для вставки в плейсхолдер лейаута произвольного
  html-контента. Кроме произвольной разметки, в плейсхолдер может быть вставлен другой виджет с помощью плагина
  ``{#widget}``.

От предыдущей версии шаблона осталась только сама надпись --- то, что действительно относится к сути данного виджета.
Теперь мы можем использовать базовую разметку (``BaseLayout``) и для других виджетов-страниц, избегая дублирования кода.

Из-за особенностей процесса сборки, после создания нового виджета может понадобиться пересобрать проект заново:

.. code-block:: bash

  cordjs run -w -C -c developer

..

  Опция ``-C`` говорит о том, что нужно удалить папку ``target/``, прежде чем собрать проект. По умолчанию, сборщик
  перекомпилирует только изменённые файлы. Того же можно добиться, выполнив команду ``cordjs clean`` перед сборкой.

В результате в браузере мы увидим то же самое, но разметка в html-исходнике будет немного отличаться --- появится
дополнительная вложенность из-за тегов ``div``, соответствующих ``{#placeholder}`` и ``{#inline}``:

.. image:: images/dom-with-layout.png

.. _quickstart-state:

Параметры и состояние (контекст) виджета
========================================

Пока что наши виджеты нет никакой динамики. Это далеко от реальной жизни. Для примера, можно "научить" ``BaseLayout``
принимать на вход заголовок (title) страницы и, соотстветственно, его отображать. Заголовок должен быть переменным,
поскольку у каждой страницы он может быть свой.

.. note::

  Почему заголовком страницы должен управлять именно ``BaseLayout``?

  Дело в том, что в CordJS "пропагандируется" принцип изоляции ответственности, т.е. каждый виджет должен отвечать
  только за ту разметку, которая присутствует в его собственном шаблоне. Виджет не должен "лезть" и модифицировать
  что-либо вне себя, за исключением публичных API других виджетов.

  Тег ``title`` должен находиться внутри ``head``, который объявлен в шаблоне виджета ``BaseLayout``.

Допишем несколько строк в класс виджета:

.. code-block:: coffee
  :linenos:
  :caption: public/bundles/hello/example/widgets/baseLayout/BaseLayout.coffee

  class BaseLayout extends Widget

    behaviourClass: false

    @initialCtx:
      title: ''

    @params:
      title: ':ctx'

..

  В ``@initialCtx`` объявляются значения по-умолчанию для переменных *контекста* виджета. **Контекст** --- структура,
  определяющая внутреннее динамическое состояние виджета. В идеале, знания шаблона и контекста виджета должно быть
  достаточно, чтобы получить отображение виджета (*в идеале*, потому что разработчики часто забывают это правило, а
  ещё некоторые аспекты отображения виджета, например, текущее положение скроллинга, технически трудно отражать в
  контексте).

  В ``@params`` перечисляются параметры, которые принимает на вход виджет и то, как виджет должен на них реагировать.
  В данном случае используется специальная (syntax-sugar) запись, которая означает команду просто записать пришедшее
  значение в одноимённую переменную контекста. По-другому то же самое можно было записать следующим образом:

  .. code-block:: coffee
    :linenos:
    :caption: public/bundles/hello/example/widgets/baseLayout/BaseLayout.coffee

    @params:
      title: (value) -> @ctx.set('title', value)

.. warning::

  Обратите внимание, что контекст (свойство ``@ctx``) виджета --- это исключительно **внутреннее** (приватное)
  состояние виджета, т.е. другие виджеты не должны пытаться читать или записывать в него напрямую. Тогда как
  параметры наоборот являются одним из аспектов публичного API виджета, т.е. того, как с ним взаимодействуют другие
  виджеты.

Добавим соответствующее изменение в шаблон виджета:

.. code-block:: html
  :linenos:
  :caption: public/bundles/hello/example/widgets/baseLayout/baseLayout.html
  :emphasize-lines: 2

  <head>
    <title>{title}</title>
    {#css/}
  </head>

..

  ``{title}`` --- обращение к переменной контекста ``@ctx.title``. Все переменные контекста доступны в шаблоне
  виджета напрямую.

Теперь мы можем использовать новый параметр в шаблоне виджета ``HelloWorldPage``:

.. code-block:: html
  :linenos:
  :caption: public/bundles/hello/example/widgets/helloWorldPage/helloWorldPage.html
  :emphasize-lines: 1

  {#extend type="//BaseLayout" title="Hello World Page"}
    {#inline}
      <h1>Hello World!</h1>
    {/inline}
  {/extend}

После этих манипуляций в браузере появится заголовок страницы "Hello World Page".

.. _quickstart-page-transitions:

Переходы между страницами (экранами)
====================================



Динамическое поведение (behaviour)
==================================


.. _quickstart-model:

Работа с данными
================

